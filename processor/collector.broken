package processor

import (
	"bytes"
	"fmt"
	"io"

	"github.com/jaqmol/approx/event"
)

// TODO: TEST AND USE IN FORMATION

// Processors are best implemented pull-based
// A collector reads events from a source as fast as it can provide

// Collector ...
type Collector struct {
	serializer chan []byte
	comms      []comm
}

// NewCollector ...
func NewCollector(inputs ...io.Reader) (*Collector, error) {
	c := &Collector{
		serializer: make(chan []byte),
		comms:      make([]comm, 0),
	}
	if len(inputs) == 0 {
		return c, nil
	}
	err := c.Connect(inputs...)
	if err != nil {
		return nil, err
	}
	return c, nil
}

// Connect ...
func (c *Collector) Connect(inputs ...io.Reader) error {
	if readerSliceIsUsable(inputs) {
		for _, r := range inputs {
			cm := comm{
				stopper: make(chan bool),
				reader:  r,
				events:  make(chan []byte),
			}
			c.comms = append(c.comms, cm)
		}
		return nil
	}
	return fmt.Errorf("Input(s) not usable: %v", inputs)
}

// Events ...
func (c *Collector) Events() <-chan []byte {
	return c.serializer
}

// Start ...
func (c *Collector) Start() {
	for _, cm := range c.comms {
		go cm.start(c.serializer)
	}
}

// Stop ...
func (c *Collector) Stop() {
	go c.stop()
}

func (c *Collector) stop() {
	for _, cm := range c.comms {
		cm.stopper <- true
	}
}

type comm struct {
	events  chan []byte
	stopper chan bool
	reader  io.Reader
}

func (c *comm) start(serializer chan<- []byte) {
	go c.scan()
	loop := true
	for loop {
		select {
		case msg := <-c.events:
			serializer <- msg
		case stp := <-c.stopper:
			loop = !stp
		}
	}
	close(c.events)
	close(c.stopper)
}

func (c *comm) scan() {
	scanner := event.NewScanner(c.reader)
	for scanner.Scan() {
		raw := scanner.Bytes()
		original := bytes.Trim(raw, "\x00")
		toPassOn := make([]byte, len(original))
		copy(toPassOn, original)
		c.events <- toPassOn
	}
}
